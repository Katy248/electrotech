// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order-queries.sql

package orders

import (
	"context"
	"time"
)

const addOrderProduct = `-- name: AddOrderProduct :exec

INSERT INTO order_products
    (order_id, product_name, product_id, quantity, product_price)
VALUES
    (?1, ?2, ?3, ?4, ?5)
`

type AddOrderProductParams struct {
	OrderID     int64
	ProductName string
	ProductID   string
	Quantity    int64
	Price       float64
}

func (q *Queries) AddOrderProduct(ctx context.Context, arg AddOrderProductParams) error {
	_, err := q.db.ExecContext(ctx, addOrderProduct,
		arg.OrderID,
		arg.ProductName,
		arg.ProductID,
		arg.Quantity,
		arg.Price,
	)
	return err
}

const getOrderProducts = `-- name: GetOrderProducts :many

SELECT id, product_id, order_id, product_name, quantity, product_price
FROM order_products
WHERE order_id = ?1
`

func (q *Queries) GetOrderProducts(ctx context.Context, id int64) ([]OrderProduct, error) {
	rows, err := q.db.QueryContext(ctx, getOrderProducts, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderProduct
	for rows.Next() {
		var i OrderProduct
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OrderID,
			&i.ProductName,
			&i.Quantity,
			&i.ProductPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many

SELECT id, user_id, creation_date
FROM orders o
WHERE user_id = ?1
`

func (q *Queries) GetOrders(ctx context.Context, userID int64) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(&i.ID, &i.UserID, &i.CreationDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrders = `-- name: GetUserOrders :many

SELECT o.id, user_id, creation_date, p.id, product_id, order_id, product_name, quantity, product_price
FROM orders o
    JOIN order_products p ON o.id = p.order_id
WHERE o.user_id = ?1
`

type GetUserOrdersRow struct {
	ID           int64
	UserID       int64
	CreationDate time.Time
	ID_2         int64
	ProductID    string
	OrderID      int64
	ProductName  string
	Quantity     int64
	ProductPrice float64
}

func (q *Queries) GetUserOrders(ctx context.Context, userID int64) ([]GetUserOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserOrders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserOrdersRow
	for rows.Next() {
		var i GetUserOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreationDate,
			&i.ID_2,
			&i.ProductID,
			&i.OrderID,
			&i.ProductName,
			&i.Quantity,
			&i.ProductPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrder = `-- name: InsertOrder :one

INSERT INTO orders
    (user_id, creation_date)
VALUES
    (?1, ?2)
RETURNING id, user_id, creation_date
`

type InsertOrderParams struct {
	UserID       int64
	CreationDate time.Time
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, insertOrder, arg.UserID, arg.CreationDate)
	var i Order
	err := row.Scan(&i.ID, &i.UserID, &i.CreationDate)
	return i, err
}
